"""
This file contains the data parser and plotter for the master thesis of Ole Oggesen
"""
import numpy as np
import matplotlib.pyplot as plt
import os
from os.path import isdir, join


def match_legend_labels(schedule_type: str):
    """
    This function is used to match the schedule type described with the folder name, to a self explanatory
    name for the legend entry.
    :param schedule_type: folder name in reports
    :return: legend replacement
    """
    label = ""
    match schedule_type:
        case "NoDataflow":
            label += "serial without dataflow"
        case "DataflowSerial":
            label += "serial with dataflow"
        case "DatflowParallel":
            label += "parallel with dataflow"

    return label


def parse_report(path: str):
    """
    This function parses the folder structure generated by the testDedup.tcl skript.

    :param path: Path to the reports folder
    :return: dictionary containing delay and input size data in ascending order
    """
    categories = list(filter(lambda d: isdir(join(path, d)), os.listdir(path)))

    output = {}
    for cat in categories:
        if cat == "synth" or cat == "impl":
            continue
        output[cat] = {}

        input_type_path = join(path, cat)
        input_types = list(filter(lambda d: isdir(join(input_type_path, d)), os.listdir(input_type_path)))

        for input_type in input_types:
            # get input size information from folder names
            size_path = join(input_type_path,
                             input_type)  # should be the path to the folder containing input size informations
            sizes = list(map(int, filter(lambda d: isdir(join(size_path, d)), os.listdir(size_path))))
            sizes.sort()

            output[cat][input_type] = {}
            output[cat][input_type]["input size"] = sizes

            # find and parse the delay values
            delays = []
            for size in sizes:
                path_to_report = join(join(size_path, str(size)), "report/verilog")

                # Read the file data and parse the delay data
                with open(join(path_to_report, "result.transaction.rpt")) as fp:
                    fp.readline()  # discard first line
                    input = fp.readline()

                    pos_colon = input.find(":")
                    pos_interval = input.find("0\n")

                    value = int(input[pos_colon + 1:pos_interval].strip())
                    delays.append(value)
            output[cat][input_type]["delay"] = delays

    return output


def main():
    """
    This functions reads parses and plots the generated data.
    :return: Void
    """
    data = parse_report("../../HLS/vitisHLS-implementation/reports")
    timing = {"NoDataflow": 8.953, "DataflowSerial": 9.696 , "DatflowParallel": 9.488} #ns
    # parse schedule types and data types into list ----------------------------------
    data_types = []
    schedule_types = []
    for schedule_type, schedule_data in data.items():

        schedule_types.append(schedule_type)
        for data_type, type_data in schedule_data.items():
            data_types.append(data_type)

    #remove duplicates
    data_types = set(data_types)
    schedule_types = set(schedule_types)



    # plot individual categories -------------- --------------------
    # latency as clock cycles
    for schedule_type, schedule_data in data.items():

        plt.figure()
        #plt.title(match_legend_labels(schedule_type))

        for data_type, type_data in schedule_data.items():
            plt.plot(list(map(lambda d: d / 1000, type_data["input size"])),
                     list(map(lambda d: d / 10 ** 6, type_data["delay"])),
                     label=data_type)

        plt.xlabel("Input size in kBytes")
        plt.ylabel("Latency in $10^{6}$ clock cycles")
        plt.xlim((0, 1000))
        plt.grid(linestyle="--")
        plt.legend()
        plt.savefig("./Plots/" + match_legend_labels(schedule_type).replace(" ", "_") + "CC.pdf", format="pdf")

    # latency in ms
    for schedule_type, schedule_data in data.items():

        plt.figure()
        #plt.title(match_legend_labels(schedule_type))

        for data_type, type_data in schedule_data.items():
            plt.plot(list(map(lambda d: d / 1000, type_data["input size"])),
                     list(map(lambda d: d * timing[schedule_type] / 10 ** 6, type_data["delay"])),
                     label=data_type)

        plt.xlabel("Input size in kBytes")
        plt.ylabel("Latency in ms")
        plt.xlim((0, 1000))
        plt.grid(linestyle="--")
        plt.legend()
        plt.savefig("./Plots/" + match_legend_labels(schedule_type).replace(" ", "_") + "MS.pdf", format="pdf")

    # plot comparisons between the scheduler/program types ----------------------------------
    # latency in clock cycles
    for data_type in data_types:
        plt.figure()
        #plt.title(data_type)

        for schedule_type, schedule_data in data.items():
            plt.plot(list(map(lambda d: d / 1000, schedule_data[data_type]["input size"])),
                     list(map(lambda d: d / 10 ** 6, schedule_data[data_type]["delay"])),
                     label=match_legend_labels(schedule_type))

        plt.xlabel("Input size in  kBytes")
        plt.ylabel("Latency in $10^{6}$ clock cycles")
        plt.xlim((0, 1000))
        plt.grid(linestyle="--")
        plt.legend()
        plt.savefig("./Plots/" + data_type.replace(" ", "_")+"CC.pdf", format="pdf")

    # latency in ms
    for data_type in data_types:
        plt.figure()
        #plt.title(data_type)

        for schedule_type, schedule_data in data.items():
            plt.plot(list(map(lambda d: d / 1000, schedule_data[data_type]["input size"])),
                     list(map(lambda d: d * timing[schedule_type]/ 10 ** 6, schedule_data[data_type]["delay"])),
                     label=match_legend_labels(schedule_type))

        plt.xlabel("Input size in  kBytes")
        plt.ylabel("Latency in ms")
        plt.xlim((0, 1000))
        plt.grid(linestyle="--")
        plt.legend()
        plt.savefig("./Plots/" + data_type.replace(" ", "_")+"MS.pdf", format="pdf")

    # print acceleration per category ----------------------------------
    for data_type in data_types:
        print("Data type: ", data_type)
        for schedule_type_1 in schedule_types:
            for schedule_type_2 in schedule_types:
                if schedule_type_1 == schedule_type_2:
                    continue

                max_delay_1 = data[schedule_type_1][data_type]["delay"][-1]
                max_delay_2 = data[schedule_type_2][data_type]["delay"][-1]
                print("\t" + schedule_type_1 + "/" + schedule_type_2 + "=", max_delay_1 / max_delay_2 * timing[schedule_type_1] / timing[schedule_type_2])
        print("")


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    main()
